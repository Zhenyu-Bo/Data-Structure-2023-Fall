# lab6

1. 我这里用了一个指针数组来表示哈夫曼树，我用了两个下标pos1,pos2，pos1记录权值最小且没有父亲的哈夫曼树结点的下标，pos2记录权值次小且没有父亲的哈夫曼结点的下标，并且我还用了min1，min2这两个变量来记录相应的权值，min1，min2都初始化为所有结点的权值之和再加上10，以确保初始时它们都是最大的，不会遗漏结点。然后枚举每个没有父亲的哈夫曼树结点，如果它的权值比min1小，就将min2更新为min1，min1更新为这个结点的权值，对应下标也做更新。否则，如果它的权值比min2小，就将min2更新为这个权值，pos2更新为这个结点对应的下标。否则不做处理。在遍历完其余所有没有父亲的哈夫曼树结点后，得到的min1，min2就是最小的两个没有父亲的结点的下标。
   在求min1，min2的外侧，我还用了一个while循环，i为循环变量，从256开始，到511-numZero(numZero是没有出现过的字符的种类数)，这样，下标i对应的哈夫曼结点就不表示字符，可用于做父节点。在求的min1，min2后，将min1，min2对应的结点连到i对应的结点，min1，min2的双亲指针也指向i，就成功找到了两个权值最小的没有父亲的结点并合为一个结点。

2. 要想构造这样一棵树，需要使每次合并两个权值最小结点后得到的结点的权值还是最小的。要想使频数之和最小，ASCII码出现的次数应该按照这样的规律分布：1，2，4，7，12，20，33，54，……这类似于斐波拉契数列但又不同，它满足这样的通项公式：an+2=an+1 + an
